const bcrypt = require("bcrypt");
const { createUser, findUserByEmail, updateUserPassword, storeOtp, getStoredOtp } = require("../services/userService");
const generateToken = require("../utils/generateToken");
const jwt = require("jsonwebtoken");
const nodemailer = require("nodemailer");

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "sharifdarjenkyleabdulhamid@gmail.com",
    pass: "iqhdcdrmneodmqxm",
  },
});

exports.register = async (req, res) => {
  try {
    const { email, password, name } = req.body;
    const existing = await findUserByEmail(email);
    if (existing) return res.status(409).json({ message: "User exists" });
    const user = await createUser({ email, password, name });
    const token = generateToken(user);
    res.status(201).json({ token });
  } catch (e) {
    res.status(500).json({ error: "Registration failed" });
  }
};
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await findUserByEmail(email);
    if (!user) return res.status(404).json({ message: "User not found" });
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(401).json({ message: "Invalid creds" });
    const token = generateToken(user);
    res.json({ token });
  } catch {
    res.status(500).json({ error: "Login failed" });
  }
};

exports.profile = async (req, res) => {
  res.json({ message: "Protected route", user: req.user });
};

// exports.requestPasswordReset = async (req, res) => {
//   try {
//     const { email } = req.body;
//     const user = await findUserByEmail(email);
//     if (!user) return res.status(404).json({ message: "User not found" });
//     const resetToken = jwt.sign({ userId: user.id }, "your-secret-key", { expiresIn: "1h" });
//     const resetUrl = `http://209.25.142.16:1508/reset-password/${resetToken}`;
//     console.log(`Reset token generated: ${resetToken}`);// Debugging log
//     await transporter.sendMail({
//       to: email,
//       subject: "Password Reset Request",
//       html: `<p>Click <a href="${resetUrl}">here</a> to reset your password. The link expires in 1 hour.</p>`,
//     });

//     res.status(200).json({ message: "Password reset email sent" });
//   } catch (e) {
//     console.error('Error in requestPasswordReset:', e);  // Debugging the error
//     res.status(500).json({ error: "Password reset request failed" });
//   }
// };

// exports.resetPassword = async (req, res) => {
//   try {
//     const { resetToken, newPassword } = req.body;
//     console.log('Reset token received:', resetToken); // Debugging log
//     const decoded = jwt.verify(resetToken, "201199201199");
//     console.log('Decoded JWT:', decoded);  // Debugging the decoded token
//     const user = await findUserByEmail(decoded.userId);
//     if (!user) return res.status(404).json({ message: "User not found" });
//     console.log('User found:', user); // Debugging log
//     const hashedPassword = await bcrypt.hash(newPassword, 10);
//     console.log('Hashed password:', hashedPassword);  // Debugging the hashed password
//     await updateUserPassword(user.id, hashedPassword);
//     res.status(200).json({ message: "Password has been reset" });
//   } catch (e) {
//     console.error('Error in resetPassword:', e);  // Debugging the error
//     res.status(500).json({ error: "Password reset failed" });
// }
// };

const crypto = require('crypto');
exports.requestOtp = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await findUserByEmail(email);
    if (!user) return res.status(404).json({ message: "User not found" });
    const otp = crypto.randomInt(100000, 999999).toString();
    const otpExpires = Date.now() + 10 * 60 * 1000;
    await storeOtp(user.id, otp, otpExpires);
    await transporter.sendMail({
      to: email,
      subject: "Your OTP Code",
      html: `<p>Your OTP code is: <strong>${otp}</strong>. It expires in 10 minutes.</p>`,
    });
    res.status(200).json({ message: "OTP sent to your email." });
  } catch (e) {
    console.error('Error in requestOtp:', e);
    res.status(500).json({ error: "Failed to send OTP" });
  }
};

exports.verifyOtp = async (req, res) => {
  try {
    const { email, otp } = req.body;
    const user = await findUserByEmail(email);
    if (!user) return res.status(404).json({ message: "User not found" });
    const storedOtp = await getStoredOtp(user.id);
    if (!storedOtp || storedOtp.otp !== otp) {
      return res.status(400).json({ message: "Invalid OTP" });
    }
    if (Date.now() > storedOtp.expiresAt) {
      return res.status(400).json({ message: "OTP expired" });
    }
    res.status(200).json({ message: "OTP verified, you can reset your password." });
  } catch (e) {
    console.error('Error in verifyOtp:', e);
    res.status(500).json({ error: "OTP verification failed" });
  }
};

exports.resetPassword = async (req, res) => {
  try {
    const { email, newPassword } = req.body;
    const user = await findUserByEmail(email);
    if (!user) return res.status(404).json({ message: "User not found" });

    const hashedPassword = await bcrypt.hash(newPassword, 10);
    await updateUserPassword(user.id, hashedPassword);

    res.status(200).json({ message: "Password reset successful" });
  } catch (e) {
    console.error('Error in resetPassword:', e);
    res.status(500).json({ error: "Password reset failed" });
  }
};