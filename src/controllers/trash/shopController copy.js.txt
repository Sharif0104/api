const prisma = require('../utils/prisma');
const { createShop, getAllShops, getShopById, bookShop: bookShopService, updateCache } = require("../services/shopService");
const { z } = require("zod");
const shopSchema = z.object({
  name: z.string().min(1, "Name is required").max(100),
  location: z.string().min(1, "Location is required").max(255),
});
exports.addShop = async (req, res) => {
  const result = shopSchema.safeParse(req.body);
  if (!result.success) {
      return res.status(400).json({
        error: "Invalid input",
        details: result.error.format(),
      });
  }
  try {
    const { name, location } = result.data;
    const shop = await createShop({ name, location });
    await updateCache(1, 10, await prisma.shop.findMany({ skip: 0, take: 10 }));
    res.status(201).json(shop);
  } catch (e) {
    console.error("Add shop error:", e.message);
    res.status(500).json({ error: "Failed to create shop" });
  }
};
const getShopsQuerySchema = z.object({
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().positive().default(10),
});
const getShopByIdSchema = z.coerce.number().int().positive();

exports.getShops = async (req, res) => {
  const query = req.query;
  const validationResult = getShopsQuerySchema.safeParse(query);
  if (!validationResult.success) {
    return res.status(400).json({ error: "Invalid query parameters" });
  }
  const { page, limit } = validationResult.data;
  try {
    const shops = await getAllShops(page, limit);
    res.json(shops);
  } catch (e) {
    console.error("Error fetching shops:", e.message);
    res.status(500).json({ error: "Failed to fetch shops" });
  }
};

exports.getShopById = async (req, res) => {
  const id = req.params.id;
  const validationResult = getShopByIdSchema.safeParse(id);
  if (!validationResult.success) {
    return res.status(400).json({ error: "Invalid shop ID" });
  }
  try {
    const shop = await getShopById(validationResult.data);
    if (!shop) {
      return res.status(404).json({ error: "Shop not found" });
    }
    res.json(shop);
  } catch (e) {
    console.error("Error fetching shop by id:", e.message);
    res.status(500).json({ error: "Failed to fetch shop by id" });
  }
};

exports.bookShop = async (req, res) => {
  try {
    const { id, date, hour } = req.params;
    const { userId } = req.body;
    if (!userId) {
      return res.status(400).json({ error: "User ID is required" });
    }
    const dateRegex = /^\d{2}-\d{2}-\d{4}$/;
    if (!date.match(dateRegex)) {
      return res.status(400).json({ error: "Invalid date format (MM-DD-YYYY)" });
    }
    if (hour < 0 || hour > 23) {
      return res.status(400).json({ error: "Hour must be between 0-23" });
    }
    const success = await bookShopService(id, date, hour, userId);
    if (success) {
      res.status(201).json({ message: "Shop booked successfully" });
    } else {
      res.status(400).json({ message: "Shop is already booked for this time" });
    }
  } catch (e) {
    console.error("Error booking shop:", e.message);
    res.status(500).json({ error: "Failed to book shop" });
  }
};

exports.getAvailableTimeSlots = async (req, res) => {
  const { shopId, date } = req.params;

  try {
    const shop = await prisma.shop.findUnique({
      where: { id: parseInt(shopId) },
      include: {
        bookings: {
          where: {
            date: new Date(date),
          },
          select: {
            hour: true,
          }
        }
      }
    });

    if (!shop) {
      return res.status(404).json({ message: "Shop not found" });
    }

    const bookedHours = shop.bookings.map(booking => booking.hour);
    const availableTimeSlots = [];
    const startHour = 9; // Starting hour for available slots (e.g., 9 AM)
    const endHour = 18; // Ending hour for available slots (e.g., 6 PM)

    for (let hour = startHour; hour <= endHour; hour++) {
      if (!bookedHours.includes(hour)) {
        availableTimeSlots.push(hour);
      }
    }

    res.status(200).json({ availableTimeSlots });
  } catch (error) {
    console.error("Error fetching available time slots:", error);
    res.status(500).json({ message: "Failed to retrieve available time slots" });
  }
};